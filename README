Triangulation 

For each frame I iterate over all the visible points, given a point point_id, I check whether it is visible in the next frame. If that is the case, I triangulate the 2 points and obtain an esimate of the point_id real position. I check whether this estimate respects following criterias: whether the estimated position is closer from the camera than z_max, wheter this estimate is not behind the camera (z<0) and whether the reprojection error is below a fixed threshold. This way I filter out some estimations that are clearly wrong.

After having done this for each frame I end up having multiple estimations for each point point_id. The final estimated position is given by the average position of all the estimates.

It is worth noting that I also tried to obtain estimates by triangulating points correspondaces in all the frames, and not only consecutive frames. This leads to worse estimations, I think this is because there is more noise/error accumulation between frames that are far from each other compared to consecutive frames, thus leading to worse estimates.

Before performing BundleAdjustment I need to define the Jacobian, which I computed using the matlab script ... , and the boxPlus operation, which is quite standard (just got to make sure to properly normalize theta).

Then I perform Bundle Adjustment. To improve robustness to outliers I perform checks similar to the ones introduced in the triangulation phase: before computing the correction dx, I skip outliers, which will greatly influence the resulting correction, by not counting the landmark estimations that, when projected on the image plane, are either behind the camera (z<0) or outside of the image plane (x>cam.width or y>cam.height). Furthermore I weight the contribution to the correction by applying a robust kernel.

To visualize the correctnes of the solution, for each step I plot the current estimate against the original estimate and the ground truth. This can also be visualized in a gif where the evolution of the relative error is also shown.

To visualize the evolution of the triangulation remove the break statement at line 20. in main.py

I found the system to be overall very sensible to the damping and kernel_threshold parameters. The additional checks to avoid outliers are also key. 

Overall the predicted solution does not converge to the ground truth, but I am not able to improve it.
